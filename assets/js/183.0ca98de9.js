(window.webpackJsonp=window.webpackJsonp||[]).push([[183],{247:function(t,e,a){"use strict";a.r(e);var n=a(2),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("用小程序·云开发将博客小程序常用功能“一网打尽”")]),t._v(" "),a("blockquote",[a("p",[t._v("本文介绍mini博客小程序的详情页的功能按钮如何实现，具体包括评论、点赞、收藏和海报功能，这里记录下整个实现过程和实际编码中的一些坑。")])]),t._v(" "),a("h2",{attrs:{id:"评论、点赞、收藏功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#评论、点赞、收藏功能","aria-hidden":"true"}},[t._v("#")]),t._v(" 评论、点赞、收藏功能")]),t._v(" "),a("h2",{attrs:{id:"实现思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现思路","aria-hidden":"true"}},[t._v("#")]),t._v(" 实现思路")]),t._v(" "),a("p",[t._v("实现文章的一些操作功能，最主要的还是评论，这是作者和读者之间沟通的桥梁，评论功能的衍生无非是细化作者和读者之间的互动，或者增加文章的传播，所以在动手开发时需要思考下你期望实现哪些功能，并对应功能进行细化。")]),t._v(" "),a("p",[t._v("我一般的经验是，先在脑子里过一遍需要的功能和大致流程，然后在笔记稍微画下「最最基础的原型，相当于产品的角色」。")]),t._v(" "),a("p",[t._v("然后就开始直接开始搭建页面和简单的交互「使用假数据，优先完成页面」，在构造页面的时候其实也能够补充最初想法上一些流程上的缺陷，这样在设计后端和数据库结构的时候可以补上，整体下来也基本比较完善了。")]),t._v(" "),a("p",[t._v("回头看我的小程序的需求，首先肯定是操作，在文章底部需要有个操作栏，用于发送点评和其他一些操作，在参考了一些同类型的小程序之后，逐步实现自己的一套风格，样式截图如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://image.bug2048.com/1557467850284.jpg",alt:""}})]),t._v(" "),a("p",[t._v("在有了功能之后，点评的数据需要有地方展示「通常是文章底部」，然后就有了文章底部的评论列表，样式如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://puui.qpic.cn/vupload/0/1566546398576_93lp95m72vm.jpeg/0",alt:""}})]),t._v(" "),a("p",[t._v("既然有"),a("code",[t._v("点赞")]),t._v("和"),a("code",[t._v("收藏")]),t._v("的功能按钮，是否用户需要看下我点赞和收藏的文章列表呢，所以在「我的」中就有相应的列表，样式如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://image.bug2048.com/1557468695860.jpg",alt:"image"}})]),t._v(" "),a("p",[t._v("到这里，最最基础的功能基本差不多，接下来就要看后端是否能支持这些页面了「主要就是数据的保存和展示了」")]),t._v(" "),a("p",[t._v("对于评论来说，肯定需要一个集合用于保存用户的评论，而对于用户的喜欢和收藏也需要一个集合来进行保存。")]),t._v(" "),a("p",[t._v("所以根据页面我们就可以设计"),a("code",[t._v("mini_comments")]),t._v("和"),a("code",[t._v("mini_posts_related")]),t._v("两个集合。前者用于保存评论数据，后者用户保存用户操作与文章之间的关联。")]),t._v(" "),a("p",[t._v("剩下的工作就是变现了，无非就是页面交互和数据的增删改查了。")]),t._v(" "),a("h2",{attrs:{id:"细节点解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#细节点解析","aria-hidden":"true"}},[t._v("#")]),t._v(" 细节点解析")]),t._v(" "),a("h4",{attrs:{id:"关于评论数量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于评论数量","aria-hidden":"true"}},[t._v("#")]),t._v(" 关于评论数量")]),t._v(" "),a("p",[t._v("目前在文章的集合中有个"),a("code",[t._v("totalComments")]),t._v("这个属性，当这篇文章每新增一个评论时，需要加1。")]),t._v(" "),a("p",[t._v("最初在写这个的时候，每次都是先查再更新，两段式，原代码如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let count=post.totalComments+1;\nlet result =await db.collection('mini_posts').doc(event.commentContent.postId).update({\n    data: {\n      totalComments: count\n    }\n  });\n")])])]),a("p",[t._v("后来看文档发现，可以使用"),a("code",[t._v("db.command.inc")]),t._v("这个指令，无需再查一遍，直接可对原字段加1，还能保证原子性。代码如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const _ = db.command\nlet result = db.collection('mini_posts').doc(event.commentContent.postId).update({\n    data: {\n      totalComments: _.inc(1)\n    }\n  });\n")])])]),a("h4",{attrs:{id:"关于新增子评论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于新增子评论","aria-hidden":"true"}},[t._v("#")]),t._v(" 关于新增子评论")]),t._v(" "),a("p",[t._v("需要实现在某个评论下进行回复。")]),t._v(" "),a("p",[t._v("在交互上，点击评论者的昵称或头像时，触发相应的点击事件，在事件中去记录相应的评论ID及必要数据，同时去设置焦点到评论框内：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(' /**\n  * 点击评论内容回复\n  */\n  focusComment: function (e) {\n    let that = this;\n    let name = e.currentTarget.dataset.name;\n    let commentId = e.currentTarget.dataset.id;\n    let openId = e.currentTarget.dataset.openid;\n\n    that.setData({\n      commentId: commentId,\n      placeholder: "回复" + name + ":",\n      focus: true,\n      toName: name,\n      toOpenId: openId\n    });\n  },\n')])])]),a("p",[t._v("利用云开发新增子评论时可以使用"),a("code",[t._v("db.command.push")]),t._v("来进行操作「更新指令，对一个值为数组的字段，往数组尾部添加一个或多个值」，往子评论集合中新增：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("/**\n * 新增子评论\n * @param {} event \n */\nasync function addPostChildComment(event) {\n\n  let task = db.collection('mini_posts').doc(event.postId).update({\n    data: {\n      totalComments: _.inc(1)\n    }\n  });\n  await db.collection('mini_comments').doc(event.id).update({\n    data: {\n      childComment: _.push(event.comments)\n    }\n  })\n  await task;\n}\n")])])]),a("h4",{attrs:{id:"关于判断是否已收藏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于判断是否已收藏","aria-hidden":"true"}},[t._v("#")]),t._v(" 关于判断是否已收藏")]),t._v(" "),a("p",[t._v("在文章第一次加载时，我们需要判断下该用户是否有对该文章有相关操作，如果有相应的收藏和点赞操作，在初始化时需要更新相应的功能图标,核心代码如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('  /**\n   * 获取收藏和喜欢的状态\n   */\n  getPostRelated: async function (blogId) {\n    let where = {\n      postId: blogId,\n      openId: app.globalData.openid\n    }\n    let postRelated = await api.getPostRelated(where, 1);\n    let that = this;\n    for (var item of postRelated.data) {\n      if (config.postRelatedType.COLLECTION === item.type) {\n        that.setData({\n          collection: { status: true, text: "已收藏", icon: "favorfill" }\n        })\n        continue;\n      }\n      if (config.postRelatedType.ZAN === item.type) {\n        that.setData({\n          zan: { status: true, text: "已赞", icon: "appreciatefill" }\n        })\n        continue;\n      }\n    }\n  },\n')])])]),a("p",[t._v("至于其他一些交互细节和代码细节，可以自行阅读源码去体会，如果有任何疑问或者有更好的实现方式，也可以与我沟通。")]),t._v(" "),a("h2",{attrs:{id:"海报功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#海报功能","aria-hidden":"true"}},[t._v("#")]),t._v(" 海报功能")]),t._v(" "),a("h2",{attrs:{id:"交代些背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#交代些背景","aria-hidden":"true"}},[t._v("#")]),t._v(" 交代些背景")]),t._v(" "),a("p",[t._v("其实在最早之前的小程序中已经实现了一次，具体可以参考"),a("a",{attrs:{href:"https://www.bug2048.com/wechat20181015/",target:"_blank",rel:"noopener noreferrer"}},[t._v("利用云开发优化博客小程序（三）——生成海报功能"),a("OutboundLink")],1),t._v(",主要还是使用原生的"),a("code",[t._v("cavans")]),t._v("进行组装，原本想代码copy过来改改就行了，但总觉得原来的代码写的不是特别好。")]),t._v(" "),a("p",[t._v("于是想看看是否有现成的轮子可以利用，果然发现了"),a("code",[t._v("wxa-plugin-canvas")]),t._v("这款组件，通过非常简单的配置就可以生成精美的海报。")]),t._v(" "),a("h2",{attrs:{id:"小程序使用npm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小程序使用npm","aria-hidden":"true"}},[t._v("#")]),t._v(" 小程序使用npm")]),t._v(" "),a("p",[t._v("在总结生成海报功能之前还是有必要记录下小程序npm的使用，避免一些不必要的坑。")]),t._v(" "),a("p",[t._v("考虑到小程序本身的大小限制，使用npm的方式是最佳的。")]),t._v(" "),a("p",[t._v("原因是根据官方文档介绍，小程序 npm 包里只有构建文件生成目录会被算入小程序包的占用空间，上传小程序代码时也只会上传该目录的代码。这样大大减少了上传的代码体积。")]),t._v(" "),a("p",[t._v("下面简单介绍下小程序端如何使用npm的「其实根据官方文档按照步骤就可以了」。")]),t._v(" "),a("p",[t._v("以我目前小程序的路径为例，在"),a("code",[t._v("/miniprogram")]),t._v("新增文件夹"),a("code",[t._v("node_modules")]),t._v(",在命令行指向到"),a("code",[t._v("/miniprogram")]),t._v("目录下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://image.bug2048.com/1557669284694.jpg",alt:"image"}})]),t._v(" "),a("p",[t._v("通过命令进行安装：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("npm install wxa-plugin-canvas --production  \n")])])]),a("p",[t._v("安装成功后，即可在小程序开发工具中进行构建，构建前需要勾选"),a("code",[t._v("使用 npm 模块")])]),t._v(" "),a("p",[a("img",{attrs:{src:"http://image.bug2048.com/1557669545807.jpg",alt:"image"}})]),t._v(" "),a("p",[t._v("然后点击开发者工具中的菜单栏：工具 --\x3e 构建 npm即可：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://image.bug2048.com/1557669634230.jpg",alt:"image"}})]),t._v(" "),a("p",[t._v("构建完成后会生成miniprogram_npm目录，到这里，项目端基本就调通了。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://puui.qpic.cn/vupload/0/1566546579976_tgmxlijrrsl.jpeg/0",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"wxa-plugin-canvas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#wxa-plugin-canvas","aria-hidden":"true"}},[t._v("#")]),t._v(" wxa-plugin-canvas")]),t._v(" "),a("p",[t._v("在构建完之后，就可以正常使用wxa-plugin-canvas这个自定义组件，使用方式还是比较简单的。")]),t._v(" "),a("p",[t._v("首先在你需要的页面引入该组件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('{\n  "usingComponents": {"poster": "wxa-plugin-canvas/poster"}\n}\n')])])]),a("p",[t._v("然后就可以在"),a("code",[t._v("wsml")]),t._v("中使用了：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<poster id="poster" hide-loading="{{false}}" preload="{{false}}" config="{{posterConfig}}" bind:success="onPosterSuccess" bind:fail="onPosterFail"></poster>\n')])])]),a("p",[t._v("由于我们在生成海报前，需要异步获取一些用于海报的数据，所以我们采用异步生成的海报方式。")]),t._v(" "),a("p",[t._v("需要引入该组件的"),a("code",[t._v("poster/poster.js")]),t._v("文件，然后在代码中调用即可：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import Poster from '../../utils/poster';\nPage({\n    /**\n     * 异步生成海报\n     */\n    onCreatePoster() {\n    \t// setData配置数据\n    \tthis.setData({ posterConfig: {...} }, () => {\n        \tPoster.create(); \n    \t});\n    }\n})\n")])])]),a("h2",{attrs:{id:"核心代码解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心代码解析","aria-hidden":"true"}},[t._v("#")]),t._v(" 核心代码解析")]),t._v(" "),a("h4",{attrs:{id:"海报需要的数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#海报需要的数据","aria-hidden":"true"}},[t._v("#")]),t._v(" 海报需要的数据")]),t._v(" "),a("p",[t._v("先来看看分享海报的整体结构：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://image.bug2048.com/1557670306978.jpg",alt:"image"}})]),t._v(" "),a("p",[t._v("首先需要确认海报的构成需要哪些数据，在调用组件前先获取好相应的数据。")]),t._v(" "),a("p",[t._v("在我设计的海报中主要包含三块内容，用户的信息(头像和昵称)，文章信息(首图,标题,简介)和最重要的文章的小程序码。")]),t._v(" "),a("p",[t._v("用户信息和文章信息其实比较简单，在小程序的详情页两者数据都有，但这里有两个问题点需要注意下。")]),t._v(" "),a("p",[t._v("第一个是域名问题，在画布中使用到的图片都需要配置域名，头像的域名和公众号文章首图的域名")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("https://mmbiz.qpic.cn\nhttps://wx.qlogo.cn\n")])])]),a("p",[a("img",{attrs:{src:"https://puui.qpic.cn/vupload/0/1566546579976_tgmxlijrrsl.jpeg/0",alt:""}})]),t._v(" "),a("p",[t._v("第二个是公众号首图的问题，公众号素材列表返回的图片url其实是"),a("code",[t._v("http")]),t._v("的，但小程序规定绑定的域名必须是"),a("code",[t._v("https")]),t._v("的，当时比较无奈，后来尝试改用https访问首图的url也可以，不幸中的万幸，所以在使用首图地址时进行替换下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("imageUrl = imageUrl.replace('http://', 'https://')\n")])])]),a("p",[t._v("最后就是文章的小程序码了，需要利用小程序的"),a("code",[t._v("getUnlimited")]),t._v("的api，具体可以参考官方文档，目前已经提供了云调用的方式「无需获取access_token」,调用起来还是比较简单的。")]),t._v(" "),a("p",[t._v("原本打算在文章同步的时候「adminService」直接生成对应文章的小程序码，代码写完后本地调试可以，但上传至云端后测试发现一直报错，逛了轮胎才知道原来不支持，同时触发器也不支持云调用，所以这个计划泡汤了，我在代码中打了TODO。")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://image.bug2048.com/1557671381977.jpg",alt:"image"}})]),t._v(" "),a("p",[t._v("既然这样，那就在生成海报的时候进行生成，同时生成后直接上传至云存储，将对应的FileID保存至文章集合中，这样只用生成一次就可以一直使用了，具体代码如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("/**\n * 新增文章二维码\n * @param {} event \n */\nasync function addPostQrCode(event)\n{\n  let scene = 'timestamp=' + event.timestamp;\n  let result = await cloud.openapi.wxacode.getUnlimited({\n    scene: scene,\n    page: 'pages/detail/detail'\n  })\n\n  if (result.errCode === 0) {\n    let upload = await cloud.uploadFile({\n      cloudPath: event.postId + '.png',\n      fileContent: result.buffer,\n    })\n\n    await db.collection(\"mini_posts\").doc(event.postId).update({\n      data: {\n        qrCode: upload.fileID\n      }\n    });\n\n    let fileList = [upload.fileID]\n    let resultUrl = await cloud.getTempFileURL({\n      fileList,\n    })\n    return resultUrl.fileList\n  }\n\n  return []\n\n}\n")])])]),a("p",[t._v("但这里有个尴尬的地方是，生成小程序码的api中的"),a("code",[t._v("scene")]),t._v("参数最大长度是32，而文章id的长度已经是32了，无法根据文章id进行拼接跳转页面的路径了，所以这里暂时用了"),a("code",[t._v("mini_posts")]),t._v("集合中timestamp字段「理论上也是唯一的」。")]),t._v(" "),a("p",[t._v("所以在详情页中也需要兼容timestamp这个字段。")]),t._v(" "),a("h4",{attrs:{id:"海报图片展示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#海报图片展示","aria-hidden":"true"}},[t._v("#")]),t._v(" 海报图片展示")]),t._v(" "),a("p",[t._v("海报图片展示就比较简单了，使用个弹窗，将生成好的海报图片进行展示即可：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  /**\n   * 生成海报成功-回调\n   * @param {} e \n   */\n  onPosterSuccess(e) {\n    const { detail } = e;\n    this.setData({\n      posterImageUrl: detail,\n      isShowPosterModal: true\n    })\n    console.info(detail)\n  },\n")])])]),a("h4",{attrs:{id:"保存海报图片"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#保存海报图片","aria-hidden":"true"}},[t._v("#")]),t._v(" 保存海报图片")]),t._v(" "),a("p",[t._v("保存图片使用wx.saveImageToPhotosAlbum调用用户相册，这里主要需要兼容用户拒绝相册授权的一些列操作，具体代码如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  /**\n  * 保存海报图片\n  */\n  savePosterImage: function () {\n    let that = this\n    wx.saveImageToPhotosAlbum({\n      filePath: that.data.posterImageUrl,\n      success(result) {\n        console.log(result)\n        wx.showModal({\n          title: '提示',\n          content: '二维码海报已存入手机相册，赶快分享到朋友圈吧',\n          showCancel: false,\n          success: function (res) {\n            that.setData({\n              isShowPosterModal: false,\n              isShow: false\n            })\n          }\n        })\n      },\n      fail: function (err) {\n        console.log(err);\n        if (err.errMsg === \"saveImageToPhotosAlbum:fail auth deny\") {\n          console.log(\"再次发起授权\");\n          wx.showModal({\n            title: '用户未授权',\n            content: '如需保存海报图片到相册，需获取授权.是否在授权管理中选中“保存到相册”?',\n            showCancel: true,\n            success: function (res) {\n              if (res.confirm) {\n                console.log('用户点击确定')\n                wx.openSetting({\n                  success: function success(res) {\n                    console.log('打开设置', res.authSetting);\n                    wx.openSetting({\n                      success(settingdata) {\n                        console.log(settingdata)\n                        if (settingdata.authSetting['scope.writePhotosAlbum']) {\n                          console.log('获取保存到相册权限成功');\n                        } else {\n                          console.log('获取保存到相册权限失败');\n                        }\n                      }\n                    })\n\n                  }\n                });\n              }\n            }\n          })\n        }\n      }\n    });\n  },\n")])])]),a("h2",{attrs:{id:"体验总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#体验总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 体验总结")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("有好的开源组件可以充分利用，避免重复造轮子，有机会也可以学习下别人的实现方式。")])]),t._v(" "),a("li",[a("p",[t._v("多看看文档，其实小程序的文档真的挺详细的。")])]),t._v(" "),a("li",[a("p",[t._v("这里主要想分享实现一个功能实现的过程，有想法的时候如何一步步去成功实现。")])]),t._v(" "),a("li",[a("p",[t._v("小程序本身不难，相应的文档也很详细，但是组装的过程和逻辑的实现需要自身去思考和体会。多看看文档，其实小程序的文档真的挺详细的。")])]),t._v(" "),a("li",[a("p",[t._v("如果你的想法和流程都非常清晰，但还是没办法实现你的预期功能，那我建议你先放放，先把"),a("code",[t._v("html")]),t._v(","),a("code",[t._v("css")]),t._v(","),a("code",[t._v("javascript")]),t._v("熟悉下，再看几遍小程序的文档，也许你当时面临的问题就不再是问题了。")])])]),t._v(" "),a("h1",{attrs:{id:"源码链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源码链接","aria-hidden":"true"}},[t._v("#")]),t._v(" 源码链接")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/CavinCao/mini-blog",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/CavinCao/mini-blog"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=s.exports}}]);